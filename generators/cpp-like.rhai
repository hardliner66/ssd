fn begin(name) {
    "// BEGIN " ++ name ++ NL
}

fn end(name) {
    "// END " ++ name ++ NL(2)
}

"// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT!!!" ++ NL(2);

"namespace " ++ model.name.join(".") ++ " {" ++ NL(2);

begin("INCLUDES");
for imp in model.imports {
    "include <" ++ imp.path.join("/") ++ ">" ++ NL
}
end("INCLUDES");

-(NL);

begin("ENUMS");

for enum in model.enums {
    "enum " ++ enum.name ++ " {";
        let prefix = "";
        for enum_value in enum.values {
            if is_some(enum_value.value) {
                prefix ++ NL ++ IND ++ enum_value.name ++ " = " ++ unwrap(enum_value.value);
            } else {
                prefix ++ NL ++ IND ++ enum_value.name;
            }
            prefix = ","
        }
    "};" ++ NL(2);
}

end("ENUMS");

-(NL);

begin("DATATYPES");

for data_type in model.data_types {
    "struct " ++ data_type.name ++ " {" ++ NL;
        for property in data_type.properties {
            IND ++ property.typ.join("::") ++ " " ++ property.name ++ ";" ++ NL;
        }
    "};" ++ NL(2);
}
end("DATATYPES");

-(NL);

begin("SERVICES");
for service in model.services {
    "class " ++ service.name ++ " {" ++ NL;
    for handler in service.handlers {
        IND ++ handler.return_type.unwrap_or("void") ++
        " " ++ handler.name ++ "(";
        
        let prefix = "";
        for argument in handler.arguments {
            prefix ++ argument.typ.join("::") ++ " " ++ argument.name;
            prefix = ", ";
        }

        ") = 0;" ++ NL;
    }
    NL ++ "};" ++ NL(2);
}
end("SERVICES");

"}" ++ NL
